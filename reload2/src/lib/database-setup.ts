import { supabaseAdmin } from './supabase';

export interface DatabaseSchema {
  name: string;
  sql: string;
}

const databaseSchemas: DatabaseSchema[] = [
  {
    name: 'executive_metrics',
    sql: `
      CREATE TABLE IF NOT EXISTS executive_metrics (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        meals_delivered BIGINT NOT NULL DEFAULT 0,
        people_served BIGINT NOT NULL DEFAULT 0,
        cost_per_meal DECIMAL(10,2) NOT NULL DEFAULT 0.00,
        program_efficiency DECIMAL(5,2) NOT NULL DEFAULT 0.00,
        revenue DECIMAL(15,2) NOT NULL DEFAULT 0.00,
        expenses DECIMAL(15,2) NOT NULL DEFAULT 0.00,
        reserves DECIMAL(15,2) NOT NULL DEFAULT 0.00,
        cash_position DECIMAL(15,2) NOT NULL DEFAULT 0.00,
        coverage_governorates INTEGER NOT NULL DEFAULT 0,
        scenario_factors JSONB DEFAULT '{}'
      );
      
      -- Create updated_at trigger
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
      END;
      $$ language 'plpgsql';
      
      CREATE TRIGGER update_executive_metrics_updated_at 
        BEFORE UPDATE ON executive_metrics 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
      
      -- Enable Row Level Security
      ALTER TABLE executive_metrics ENABLE ROW LEVEL SECURITY;
      
      -- Create RLS policies
      CREATE POLICY "Allow public read access" ON executive_metrics
        FOR SELECT USING (true);
        
      CREATE POLICY "Allow admin insert" ON executive_metrics
        FOR INSERT WITH CHECK (auth.role() = 'service_role');
        
      CREATE POLICY "Allow admin update" ON executive_metrics
        FOR UPDATE USING (auth.role() = 'service_role');
        
      CREATE POLICY "Allow admin delete" ON executive_metrics
        FOR DELETE USING (auth.role() = 'service_role');
    `
  },
  {
    name: 'users',
    sql: `
      CREATE TABLE IF NOT EXISTS users (
        id UUID REFERENCES auth.users(id) PRIMARY KEY,
        email TEXT NOT NULL UNIQUE,
        role TEXT NOT NULL DEFAULT 'viewer' CHECK (role IN ('admin', 'viewer', 'editor')),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        last_login TIMESTAMP WITH TIME ZONE
      );
      
      -- Create updated_at trigger
      CREATE TRIGGER update_users_updated_at 
        BEFORE UPDATE ON users 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
      
      -- Enable Row Level Security
      ALTER TABLE users ENABLE ROW LEVEL SECURITY;
      
      -- Create RLS policies
      CREATE POLICY "Allow users to view their own data" ON users
        FOR SELECT USING (auth.uid() = id);
        
      CREATE POLICY "Allow admins to manage users" ON users
        FOR ALL USING (
          auth.uid() = id OR 
          EXISTS (
            SELECT 1 FROM users 
            WHERE id = auth.uid() AND role = 'admin'
          )
        );
    `
  },
  {
    name: 'audit_logs',
    sql: `
      CREATE TABLE IF NOT EXISTS audit_logs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id UUID REFERENCES auth.users(id) NOT NULL,
        action TEXT NOT NULL,
        table_name TEXT NOT NULL,
        record_id TEXT NOT NULL,
        old_data JSONB,
        new_data JSONB,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
      );
      
      -- Create indexes for better performance
      CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
      CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON audit_logs(table_name);
      CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);
      
      -- Enable Row Level Security
      ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
      
      -- Create RLS policies
      CREATE POLICY "Allow users to view their own audit logs" ON audit_logs
        FOR SELECT USING (auth.uid() = user_id);
        
      CREATE POLICY "Allow admins to view all audit logs" ON audit_logs
        FOR SELECT USING (
          EXISTS (
            SELECT 1 FROM users 
            WHERE id = auth.uid() AND role = 'admin'
          )
        );
        
      CREATE POLICY "Allow system to create audit logs" ON audit_logs
        FOR INSERT WITH CHECK (auth.role() = 'service_role');
    `
  },
  {
    name: 'scenarios',
    sql: `
      CREATE TABLE IF NOT EXISTS scenarios (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        factors JSONB NOT NULL DEFAULT '{}',
        results JSONB DEFAULT '{}',
        created_by UUID REFERENCES auth.users(id),
        is_active BOOLEAN DEFAULT false
      );
      
      -- Create updated_at trigger
      CREATE TRIGGER update_scenarios_updated_at 
        BEFORE UPDATE ON scenarios 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
      
      -- Enable Row Level Security
      ALTER TABLE scenarios ENABLE ROW LEVEL SECURITY;
      
      -- Create RLS policies
      CREATE POLICY "Allow users to view scenarios" ON scenarios
        FOR SELECT USING (true);
        
      CREATE POLICY "Allow authenticated users to create scenarios" ON scenarios
        FOR INSERT WITH CHECK (auth.uid() = created_by);
        
      CREATE POLICY "Allow users to update their own scenarios" ON scenarios
        FOR UPDATE USING (auth.uid() = created_by);
        
      CREATE POLICY "Allow admins to manage all scenarios" ON scenarios
        FOR ALL USING (
          EXISTS (
            SELECT 1 FROM users 
            WHERE id = auth.uid() AND role = 'admin'
          )
        );
    `
  }
];

export async function setupDatabase() {
  console.log('Setting up database schema...');
  
  for (const schema of databaseSchemas) {
    try {
      console.log(`Creating table: ${schema.name}`);
      
      const { error } = await supabaseAdmin.rpc('exec_sql', {
        sql: schema.sql
      });
      
      if (error) {
        console.error(`Error creating ${schema.name}:`, error);
        
        // Fallback: Try to execute the SQL directly
        try {
          const { error: directError } = await supabaseAdmin
            .from(schema.name)
            .select('*')
            .limit(1);
          
          if (directError && directError.code === '42P01') {
            console.log(`Table ${schema.name} doesn't exist, please create it manually in Supabase dashboard`);
          } else {
            console.log(`Table ${schema.name} already exists or was created successfully`);
          }
        } catch (fallbackError) {
          console.error(`Fallback check failed for ${schema.name}:`, fallbackError);
        }
      } else {
        console.log(`Successfully created table: ${schema.name}`);
      }
    } catch (error) {
      console.error(`Unexpected error creating ${schema.name}:`, error);
    }
  }
  
  console.log('Database setup completed');
  
  // Insert initial data
  await insertInitialData();
}

async function insertInitialData() {
  try {
    // Check if executive metrics data already exists
    const { data: existingData, error: checkError } = await supabaseAdmin
      .from('executive_metrics')
      .select('id')
      .limit(1);
    
    if (checkError) {
      console.error('Error checking existing data:', checkError);
      return;
    }
    
    if (!existingData || existingData.length === 0) {
      // Insert initial executive metrics
      const { error: insertError } = await supabaseAdmin
        .from('executive_metrics')
        .insert([{
          meals_delivered: 367490721,
          people_served: 4960000,
          cost_per_meal: 6.36,
          program_efficiency: 83,
          revenue: 2200000000,
          expenses: 2316000000,
          reserves: 731200000,
          cash_position: 459800000,
          coverage_governorates: 27,
          scenario_factors: {
            economicGrowth: 0,
            inflationRate: 0,
            donorSentiment: 0,
            operationalEfficiency: 0,
            foodPrices: 0,
            unemploymentRate: 0,
            corporateCSR: 0,
            governmentSupport: 0,
            exchangeRateEGP: 0,
            logisticsCostIndex: 0,
            regionalShock: 0
          }
        }]);
      
      if (insertError) {
        console.error('Error inserting initial data:', insertError);
      } else {
        console.log('Initial executive metrics data inserted successfully');
      }
    } else {
      console.log('Executive metrics data already exists');
    }
  } catch (error) {
    console.error('Error inserting initial data:', error);
  }
}

// Function to create a custom exec_sql function if it doesn't exist
export async function createExecFunction() {
  const createFunctionSQL = `
    CREATE OR REPLACE FUNCTION exec_sql(sql text)
    RETURNS VOID AS $$
    BEGIN
      EXECUTE sql;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
  `;
  
  try {
    const { error } = await supabaseAdmin.rpc('exec_sql', {
      sql: createFunctionSQL
    });
    
    if (error) {
      console.log('exec_sql function may already exist or needs to be created manually');
    } else {
      console.log('exec_sql function created successfully');
    }
  } catch (error) {
    console.log('exec_sql function setup completed');
  }
}
